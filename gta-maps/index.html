<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GTA Maps - Vista A√©rea</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #333;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #map {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0; left: 0; z-index: 1;
        }

        #car {
            position: absolute;
            top: 50%; left: 50%;
            width: 14px; height: 28px; 
            background: #d32f2f; 
            margin-top: -14px; margin-left: -7px; 
            border-radius: 3px; z-index: 10;
            box-shadow: 0 8px 12px rgba(0,0,0,0.6);
        }

        #car::before {
            content: ''; position: absolute;
            top: 7px; left: 1px; right: 1px; height: 5px; 
            background: #111; border-radius: 1px 1px 0 0; border-top: 1px solid #555;
        }

        #car::after {
            content: ''; position: absolute;
            bottom: 4px; left: 2px; right: 2px; height: 4px; 
            background: #111; border-radius: 0 0 1px 1px;
        }

        .roof {
            position: absolute; top: 12px; left: 2px; right: 2px; height: 9px; 
            background: #b71c1c; border-radius: 2px;
        }

        #player {
            position: absolute;
            top: 50%; left: 50%;
            width: 14px; height: 8px;
            margin-top: -4px; margin-left: -7px;
            z-index: 15;
            display: none; 
        }

        #player-body {
            position: absolute;
            top: -1px; left: -1px;
            width: 14px; height: 8px; 
            background: #FFD700; 
            border: 1px solid #000;
            border-radius: 4px; 
            z-index: 2; 
            box-shadow: 0 4px 6px rgba(0,0,0,0.5);
        }

        #player-head {
            position: absolute;
            top: 50%; left: 50%;
            width: 8px; height: 8px;
            background: #111; 
            margin-top: -4px; margin-left: -4px;
            border-radius: 50%;
            z-index: 3; 
        }

        .player-foot {
            position: absolute;
            width: 4px; height: 6px; 
            background: #111; 
            border-radius: 2px;
            z-index: 1; 
        }

        #player-foot-l { left: 2px; top: 0px; }
        #player-foot-r { right: 2px; top: 0px; }

        #ui {
            position: absolute; bottom: 20px; right: 20px;
            background: rgba(0, 0, 0, 0.8); color: #0f0;
            padding: 15px; border: 2px solid #0f0; border-radius: 10px;
            z-index: 20; text-align: right; user-select: none;
            transition: border-color 0.3s ease, opacity 0.5s ease; 
        }

        #speedometer { font-size: 32px; font-weight: bold; }

        #reputation-ui {
            position: absolute; top: 20px; right: 20px;
            background: rgba(0, 0, 0, 0.8); color: white;
            padding: 15px; border: 2px solid white; border-radius: 10px;
            z-index: 20; text-align: center; user-select: none; min-width: 150px;
            transition: border-color 0.3s ease, color 0.3s ease, opacity 0.5s ease; 
        }

        #survival-score { font-size: 28px; font-weight: bold; }
        #stars-container { font-size: 24px; margin-top: 5px; letter-spacing: 2px; }
        .star { color: #555; transition: color 0.3s ease; }
        .star.active { color: #FFD700; text-shadow: 0 0 5px #FFD700; }

        #stamina-bar-container {
            width: 100%; height: 6px; background: #555; border-radius: 3px; 
            margin-top: 10px; overflow: hidden; display: none;
        }
        #stamina-bar {
            width: 100%; height: 100%; background: #2196F3; 
            transition: width 0.1s linear, background-color 0.3s;
        }

        #location-display {
            margin-top: 15px; padding-top: 10px; border-top: 1px solid #555;
            text-transform: uppercase; letter-spacing: 1px; line-height: 1.4;
            max-width: 160px; margin-left: auto; margin-right: auto;
        }
        #loc-neighborhood {
            font-weight: bold; color: #fff; font-size: 13px;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis; 
        }
        #loc-city-state {
            font-size: 11px; color: #ccc; white-space: nowrap;
            overflow: hidden; text-overflow: ellipsis; margin-top: 2px;
        }

        #instructions {
            position: absolute; bottom: 20px; left: 20px;
            background: rgba(0, 0, 0, 0.8); color: white;
            padding: 15px; border-radius: 10px; z-index: 20; user-select: none;
            transition: opacity 0.5s ease;
            pointer-events: auto; 
        }

        .control-switch-container {
            display: flex; align-items: center; justify-content: center; gap: 10px; 
            margin-top: 15px; border-top: 1px solid #555; padding-top: 15px;
        }
        .mode-label { font-size: 14px; font-weight: bold; color: #ddd; }
        .switch { position: relative; display: inline-block; width: 44px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #555; transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #4CAF50; }
        input:checked + .slider:before { transform: translateX(20px); }

        .instruction-buttons {
            display: flex; gap: 10px; margin-top: 15px;
        }

        .inst-btn {
            background: rgba(255, 255, 255, 0.1); color: white; width: 100%;
            border: 1px solid white; border-radius: 5px;
            padding: 8px 12px; font-size: 14px; cursor: pointer;
            display: flex; justify-content: center; align-items: center; gap: 5px;
            transition: transform 0.2s, background 0.2s;
        }
        .inst-btn:active { transform: scale(0.95); background: rgba(255, 255, 255, 0.3); }

        kbd {
            background: #eee; color: #333; padding: 2px 6px;
            border-radius: 3px; font-family: sans-serif; font-size: 14px;
        }

        #game-title {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            color: #fff; font-size: 48px; font-weight: 900; font-family: Impact, sans-serif;
            text-shadow: 3px 3px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
            z-index: 30; pointer-events: none; letter-spacing: 3px; font-style: italic;
            transition: opacity 0.5s ease;
        }

        #search-container {
            position: absolute; top: 85px; left: 50%; transform: translateX(-50%);
            z-index: 30; display: flex; gap: 5px;
            background: rgba(0,0,0,0.7); padding: 10px; border-radius: 8px;
            transition: opacity 0.5s ease;
        }

        #address-input { padding: 8px; font-size: 16px; width: 220px; border: none; border-radius: 4px; outline: none; }
        #search-btn { padding: 8px 15px; font-size: 16px; cursor: pointer; background: #d32f2f; color: white; border: none; border-radius: 4px; font-weight: bold; transition: background 0.2s; }
        #search-btn:hover { background: #b71c1c; }

        @media (max-width: 600px) {
            #game-title { font-size: 32px; top: 10px; }
            #search-container { top: 60px; }
            #address-input { width: 150px; }
            #reputation-ui { transform: scale(0.8); transform-origin: top right; }
            #ui { transform: scale(0.8); transform-origin: bottom right; right: 10px; bottom: 10px; }
            #instructions { font-size: 11px; bottom: 10px; left: 10px; padding: 10px; }
            .inst-btn { padding: 6px 8px; font-size: 12px; }
        }

        #car-smoke {
            position: absolute; bottom: -10px; left: 50%;
            width: 8px; height: 8px; background: #333; border-radius: 50%;
            z-index: 5; display: none;
        }

        .smoking { display: block !important; animation: smoke-anim 0.6s linear infinite; }
        @keyframes smoke-anim {
            0% { transform: translateX(-50%) scale(1); opacity: 0.8; bottom: -10px; }
            100% { transform: translateX(-50%) scale(4); opacity: 0; bottom: -30px; }
        }

        #loading-text {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 32px;
            font-weight: bold;
            font-family: 'Courier New', Courier, monospace;
            text-shadow: 2px 2px 5px #000;
            z-index: 200;
            display: none; 
            pointer-events: none;
            letter-spacing: 2px;
            animation: blink 1s infinite alternate;
        }

        /* ‚îÄ‚îÄ DEBUG OVERLAY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
        #debug-svg {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none; z-index: 8;
            display: none;
        }
        #debug-svg.active { display: block; }
        .debug-road { stroke: rgba(255,200,0,0.55); stroke-width: 2; fill: none; }
        .debug-building { stroke: rgba(255,80,80,0.5); stroke-width: 1.5; fill: rgba(255,80,80,0.07); }
        .debug-obb { stroke: lime; stroke-width: 1.5; fill: none; }

        #debug-btn {
            position: absolute; bottom: 20px; right: 20px;
            background: rgba(0,0,0,0.7); color: #ffeb3b;
            border: 1px solid #ffeb3b; border-radius: 6px;
            padding: 5px 10px; font-size: 11px; cursor: pointer;
            z-index: 50; display: none;
        }
        #debug-btn.visible { display: block; }

        /* ‚îÄ‚îÄ CITY SELECT SCREEN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
        #city-select {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #0a0a0a;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 500; font-family: 'Courier New', monospace;
        }
        #city-select h1 {
            color: #fff; font-size: 52px; font-weight: 900;
            font-family: Impact, sans-serif; letter-spacing: 4px;
            font-style: italic; margin: 0 0 4px 0;
            text-shadow: 3px 3px 0 #d32f2f;
        }
        #city-select .subtitle {
            color: #888; font-size: 13px; letter-spacing: 3px;
            text-transform: uppercase; margin-bottom: 36px;
        }
        .city-grid {
            display: grid; grid-template-columns: 1fr 1fr;
            gap: 12px; width: min(520px, 92vw); margin-bottom: 16px;
        }
        .city-btn {
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px; padding: 16px 18px;
            color: #fff; cursor: pointer; text-align: left;
            transition: background 0.18s, border-color 0.18s, transform 0.12s;
        }
        .city-btn:hover { background: rgba(255,255,255,0.1); border-color: rgba(255,255,255,0.4); transform: scale(1.02); }
        .city-btn .flag { font-size: 22px; display: block; margin-bottom: 6px; }
        .city-btn .city-name { font-size: 16px; font-weight: bold; }
        .city-btn .city-desc { font-size: 11px; color: #888; margin-top: 2px; }
        .city-btn.special { border-color: rgba(211,47,47,0.5); }
        .city-btn.special:hover { border-color: #d32f2f; background: rgba(211,47,47,0.12); }

        .city-divider {
            color: #444; font-size: 11px; letter-spacing: 2px;
            text-transform: uppercase; margin: 8px 0; width: min(520px,92vw); text-align: center;
        }

        /* Search box dentro da city-select */
        #city-search-wrap {
            width: min(520px,92vw); display: none; flex-direction: column; gap: 8px;
        }
        #city-search-wrap.visible { display: flex; }
        #city-search-input {
            background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px; padding: 12px 14px; color: #fff; font-size: 15px;
            font-family: inherit; outline: none; width: 100%; box-sizing: border-box;
        }
        #city-search-input::placeholder { color: #666; }
        #city-search-results { display: flex; flex-direction: column; gap: 6px; }
        .search-result-btn {
            background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px; padding: 11px 14px; color: #ddd; cursor: pointer;
            text-align: left; font-size: 13px; transition: background 0.15s;
        }
        .search-result-btn:hover { background: rgba(255,255,255,0.1); }

        /* ‚îÄ‚îÄ CUTSCENE / LOADING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
        #cutscene {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 400;
            display: none; flex-direction: column;
            align-items: center; justify-content: flex-end;
            padding-bottom: 80px; box-sizing: border-box;
        }
        #cutscene.active { display: flex; }
        #cutscene-bars-top, #cutscene-bars-bot {
            position: absolute; left: 0; right: 0; height: 70px;
            background: #000; z-index: 2;
            transition: height 0.6s ease;
        }
        #cutscene-bars-top { top: 0; }
        #cutscene-bars-bot { bottom: 0; }
        #cutscene-city-name {
            color: #fff; font-size: 42px; font-weight: 900;
            font-family: Impact, sans-serif; letter-spacing: 3px;
            font-style: italic; z-index: 3; text-align: center;
            text-shadow: 2px 2px 0 #000;
            opacity: 0; transition: opacity 0.5s ease;
        }
        #cutscene-status {
            color: #888; font-size: 12px; letter-spacing: 3px;
            text-transform: uppercase; z-index: 3; margin-top: 10px;
            opacity: 0; transition: opacity 0.4s ease 0.3s;
        }
        #cutscene-progress-wrap {
            width: min(340px, 80vw); height: 3px;
            background: rgba(255,255,255,0.1); border-radius: 2px;
            margin-top: 18px; overflow: hidden; z-index: 3;
            opacity: 0; transition: opacity 0.4s ease 0.4s;
        }
        #cutscene-progress {
            height: 100%; width: 0%; background: #d32f2f;
            transition: width 0.3s ease;
        }
            position: absolute;
            bottom: 90px; left: 20px;
            background: rgba(0,0,0,0.7); color: #ffeb3b;
            padding: 6px 12px; border-radius: 6px;
            font-size: 12px; z-index: 25;
            display: none;
            border: 1px solid #ffeb3b;
        }

        @keyframes blink {
            0% { opacity: 1; }
            100% { opacity: 0.3; }
        }

        .police-car {
            position: absolute; width: 14px; height: 28px;
            background: #111; margin-top: -14px; margin-left: -7px;
            border-radius: 3px; z-index: 9;
            box-shadow: 0 8px 12px rgba(0,0,0,0.6);
            display: none;
        }
        .police-car::before {
            content: ''; position: absolute;
            top: 7px; left: 1px; right: 1px; height: 5px;
            background: #222; border-radius: 1px 1px 0 0; border-top: 1px solid #555;
        }
        .police-car::after {
            content: ''; position: absolute;
            bottom: 4px; left: 2px; right: 2px; height: 4px;
            background: #222; border-radius: 0 0 1px 1px;
        }
        .police-roof {
            position: absolute; top: 12px; left: 2px; right: 2px; height: 9px;
            background: #fff; border-radius: 2px;
        }
        .siren {
            position: absolute; top: 2px; left: 1px; right: 1px; height: 3px;
            background: linear-gradient(to right, red 50%, blue 50%);
            animation: siren-flash 0.3s infinite;
        }
        @keyframes siren-flash {
            0% { box-shadow: -4px 0 10px red, 4px 0 10px blue; }
            50% { box-shadow: -4px 0 10px blue, 4px 0 10px red; background: linear-gradient(to right, blue 50%, red 50%); }
            100% { box-shadow: -4px 0 10px red, 4px 0 10px blue; }
        }

        /* Modo investida: sirene pisca muito mais r√°pido e fica laranja */
        .police-car.ramming .siren {
            animation: siren-ram 0.1s infinite;
        }
        @keyframes siren-ram {
            0%   { background: #ff6600; box-shadow: 0 0 14px 6px #ff6600; }
            50%  { background: #fff; box-shadow: 0 0 14px 6px #fff; }
            100% { background: #ff6600; box-shadow: 0 0 14px 6px #ff6600; }
        }

        /* Modo stunned: sirene apagada */
        .police-car.stunned-state .siren {
            animation: none;
            background: #444;
            box-shadow: none;
        }
        .police-car.stunned-state {
            opacity: 0.6;
        }

        #thought-bubble {
            position: absolute;
            top: 35%; left: 55%;
            background: white; color: black;
            padding: 10px 15px; border-radius: 15px;
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Marker Felt', sans-serif;
            font-weight: bold; font-size: 14px;
            z-index: 25; display: none;
            box-shadow: 2px 2px 10px rgba(0,0,0,0.5);
            pointer-events: none;
            transform: translate(-50%, -50%);
            white-space: nowrap;
        }
        #thought-bubble::after {
            content: '';
            position: absolute;
            bottom: -8px; left: 20px;
            border-width: 8px 8px 0 0;
            border-style: solid;
            border-color: white transparent transparent transparent;
        }

        #wasted-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.75); display: none; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100;
        }

        #wasted-text {
            color: #d32f2f; font-size: 80px; font-weight: 900; font-family: Impact, sans-serif;
            text-shadow: 4px 4px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 2px 2px 0 #000;
            letter-spacing: 5px; margin-bottom: 5px; text-align: center;
        }
        
        #wasted-reason {
            color: #fff; font-size: 20px; font-family: sans-serif;
            margin-bottom: 25px; text-transform: uppercase; font-weight: bold; text-align: center;
        }

        #wasted-score-display { color: white; font-size: 28px; font-family: sans-serif; margin-bottom: 40px; text-shadow: 2px 2px 0 #000; }
        #restart-btn { padding: 15px 30px; font-size: 24px; cursor: pointer; background: #d32f2f; color: white; border: none; border-radius: 5px; font-weight: bold; font-family: sans-serif; transition: background 0.2s, transform 0.1s; }
        #restart-btn:hover { background: #b71c1c; }
        #restart-btn:active { transform: scale(0.95); }
    </style>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
</head>
<body>

    <!-- ‚îÄ‚îÄ CITY SELECT SCREEN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
    <div id="city-select">
        <h1>GTA MAPS</h1>
        <div class="subtitle">Escolha onde dirigir</div>

        <div class="city-grid" id="city-grid">
            <button class="city-btn" data-lat="40.7580" data-lng="-73.9855" data-name="Nova York">
                <span class="flag">üóΩ</span>
                <div class="city-name">Nova York</div>
                <div class="city-desc">Times Square, Manhattan</div>
            </button>
            <button class="city-btn" data-lat="48.8584" data-lng="2.2945" data-name="Paris">
                <span class="flag">üóº</span>
                <div class="city-name">Paris</div>
                <div class="city-desc">Torre Eiffel, Fran√ßa</div>
            </button>
            <button class="city-btn" data-lat="35.6762" data-lng="139.6503" data-name="T√≥quio">
                <span class="flag">üóæ</span>
                <div class="city-name">T√≥quio</div>
                <div class="city-desc">Shibuya, Jap√£o</div>
            </button>
            <button class="city-btn" data-lat="-23.5505" data-lng="-46.6333" data-name="S√£o Paulo">
                <span class="flag">üáßüá∑</span>
                <div class="city-name">S√£o Paulo</div>
                <div class="city-desc">Av. Paulista, Brasil</div>
            </button>
        </div>

        <div class="city-divider">‚îÄ‚îÄ especial ‚îÄ‚îÄ</div>

        <div class="city-grid" style="margin-bottom:0">
            <button class="city-btn special" id="btn-gps">
                <span class="flag">üìç</span>
                <div class="city-name">Minha localiza√ß√£o</div>
                <div class="city-desc">Usar GPS do navegador</div>
            </button>
            <button class="city-btn special" id="btn-custom">
                <span class="flag">üîç</span>
                <div class="city-name">Endere√ßo especial</div>
                <div class="city-desc">Digitar um endere√ßo</div>
            </button>
        </div>

        <div id="city-search-wrap">
            <input type="text" id="city-search-input" placeholder="Ex: Rua Augusta, S√£o Paulo...">
            <div id="city-search-results"></div>
        </div>
    </div>

    <!-- ‚îÄ‚îÄ CUTSCENE / LOADING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
    <div id="cutscene">
        <div id="cutscene-bars-top"></div>
        <div id="cutscene-bars-bot"></div>
        <div id="cutscene-city-name">Nova York</div>
        <div id="cutscene-status">Carregando mapa...</div>
        <div id="cutscene-progress-wrap">
            <div id="cutscene-progress"></div>
        </div>
    </div>

    <!-- ‚îÄ‚îÄ DEBUG SVG OVERLAY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
    <svg id="debug-svg"></svg>
    <button id="debug-btn">üîß DEBUG</button>

    <div id="map"></div>

    <div id="car">
        <div class="roof"></div>
        <div id="car-smoke"></div> 
    </div>

    <div id="thought-bubble"></div>
    <div id="loading-text">CARREGANDO MAPA...</div>
    <div id="map-status"></div>

    <div id="player">
        <div id="player-foot-l" class="player-foot"></div>
        <div id="player-foot-r" class="player-foot"></div>
        <div id="player-body"></div> 
        <div id="player-head"></div>
    </div>

    <div id="game-title">GTA MAPS</div>

    <div id="search-container">
        <input type="text" id="address-input" placeholder="Onde quer dirigir?">
        <button id="search-btn">Buscar</button>
    </div>

    <div id="instructions">
        <div id="instructions-text">
            <h3 style="margin-top:0">TECLADO</h3>
            <p><kbd>‚Üë</kbd> <kbd>‚Üì</kbd> <kbd>‚Üê</kbd> <kbd>‚Üí</kbd> : Mover</p>
            <p><kbd>Shift</kbd> : Acelerar+</p>
            <p><kbd>Espa√ßo</kbd> : Entrar/Sair</p>
        </div>
        
        <div class="control-switch-container">
            <span class="mode-label">‚å®Ô∏è Teclado</span>
            <label class="switch">
                <input type="checkbox" id="control-switch">
                <span class="slider"></span>
            </label>
            <span class="mode-label">üì± Celular</span>
        </div>

        <div class="instruction-buttons">
            <button id="btn-fullscreen" class="inst-btn" title="Tela Cheia">‚õ∂ Tela Cheia</button>
        </div>
    </div>

    <div id="wasted-screen">
        <div id="wasted-text">WASTED</div>
        <div id="wasted-reason"></div>
        <div id="wasted-score-display">Sobreviv√™ncia: <span id="final-score">0</span></div>
        <button id="restart-btn">Tentar Novamente</button>
    </div>

    <div id="reputation-ui">
        <div>SOBREVIV√äNCIA</div>
        <div id="survival-score">0</div>
        <div id="stars-container">
            <span class="star" id="star-1">‚òÖ</span>
            <span class="star" id="star-2">‚òÖ</span>
            <span class="star" id="star-3">‚òÖ</span>
            <span class="star" id="star-4">‚òÖ</span>
            <span class="star" id="star-5">‚òÖ</span>
        </div>
        <div id="stamina-bar-container">
            <div id="stamina-bar"></div>
        </div>
        <div id="location-display">
            <div id="loc-neighborhood">üìç GPS...</div>
            <div id="loc-city-state">Conectando</div>
        </div>
    </div>

    <div id="ui">
        <div id="speedometer">0</div>
        <div>km/h</div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
        // ============================================================
        // CONFIGURA√á√ÉO DE APIs COM FALLBACK
        // ============================================================

        // Mirrors do Overpass em ordem de prefer√™ncia
        const OVERPASS_MIRRORS = [
            'https://overpass-api.de/api/interpreter',
            'https://overpass.kumi.systems/api/interpreter',
            'https://maps.mail.ru/osm/tools/overpass/api/interpreter',
            'https://overpass.openstreetmap.ru/api/interpreter'
        ];

        // Geocoding reverso com fallback
        async function reverseGeocode(lat, lng) {
            // Tenta Nominatim (mais confi√°vel e sem CORS)
            try {
                const res = await fetch(
                    `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json&accept-language=pt-BR`,
                    { headers: { 'Accept-Language': 'pt-BR,pt;q=0.9' } }
                );
                if (res.ok) {
                    const data = await res.json();
                    if (data && data.address) {
                        const a = data.address;
                        const neighborhood = a.suburb || a.neighbourhood || a.quarter || a.village || a.town || a.city_district || a.road || "√Årea Desconhecida";
                        const city = a.city || a.town || a.village || a.municipality || "";
                        const state = a.state || "";
                        return { neighborhood, city, state };
                    }
                }
            } catch(e) {}

            // Fallback: Photon
            try {
                const res = await fetch(`https://photon.komoot.io/reverse?lon=${lng}&lat=${lat}`);
                if (res.ok) {
                    const data = await res.json();
                    if (data?.features?.length > 0) {
                        const p = data.features[0].properties;
                        return {
                            neighborhood: p.district || p.suburb || p.neighbourhood || p.name || "√Årea Desconhecida",
                            city: p.city || p.town || p.village || "",
                            state: p.state || ""
                        };
                    }
                }
            } catch(e) {}

            return null;
        }

        // Geocoding direto (busca) com fallback
        async function geocodeAddress(query) {
            // Tenta Nominatim primeiro
            try {
                const res = await fetch(
                    `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=1`,
                    { headers: { 'Accept-Language': 'pt-BR,pt;q=0.9' } }
                );
                if (res.ok) {
                    const data = await res.json();
                    if (data?.length > 0) {
                        return { lat: parseFloat(data[0].lat), lng: parseFloat(data[0].lon) };
                    }
                }
            } catch(e) {}

            // Fallback: Photon
            try {
                const res = await fetch(`https://photon.komoot.io/api/?q=${encodeURIComponent(query)}&limit=1`);
                if (res.ok) {
                    const data = await res.json();
                    if (data?.features?.length > 0) {
                        return {
                            lat: parseFloat(data.features[0].geometry.coordinates[1]),
                            lng: parseFloat(data.features[0].geometry.coordinates[0])
                        };
                    }
                }
            } catch(e) {}

            return null;
        }

        // Geolocaliza√ß√£o IP com m√∫ltiplos fallbacks
        async function getIPLocation() {
            const services = [
                async () => {
                    const r = await fetch('https://ipapi.co/json/', { signal: AbortSignal.timeout(4000) });
                    const d = await r.json();
                    if (d.latitude) return { lat: parseFloat(d.latitude), lng: parseFloat(d.longitude) };
                    return null;
                },
                async () => {
                    const r = await fetch('https://get.geojs.io/v1/ip/geo.json', { signal: AbortSignal.timeout(4000) });
                    const d = await r.json();
                    if (d.latitude) return { lat: parseFloat(d.latitude), lng: parseFloat(d.longitude) };
                    return null;
                },
                async () => {
                    const r = await fetch('https://ip-api.com/json/?fields=lat,lon,status', { signal: AbortSignal.timeout(4000) });
                    const d = await r.json();
                    if (d.status === 'success') return { lat: d.lat, lng: d.lon };
                    return null;
                }
            ];

            for (const service of services) {
                try {
                    const result = await service();
                    if (result) return result;
                } catch(e) {}
            }
            return null; // Usa padr√£o (SP) se tudo falhar
        }

        // Overpass com retry em mirrors diferentes
        let currentOverpassMirror = 0;
        async function fetchOverpass(query) {
            const url = `data=${encodeURIComponent(query)}`;
            const mirrorsToTry = [...OVERPASS_MIRRORS.slice(currentOverpassMirror), ...OVERPASS_MIRRORS.slice(0, currentOverpassMirror)];
            
            for (let i = 0; i < mirrorsToTry.length; i++) {
                const mirror = mirrorsToTry[i];
                try {
                    showMapStatus(`Carregando mapa... (servidor ${i + 1}/${mirrorsToTry.length})`);
                    const response = await fetch(mirror, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                        body: url,
                        signal: AbortSignal.timeout(12000)
                    });
                    
                    if (!response.ok) continue;
                    
                    const text = await response.text();
                    const data = JSON.parse(text);
                    
                    // Sucesso! Lembra o mirror que funcionou
                    currentOverpassMirror = OVERPASS_MIRRORS.indexOf(mirror);
                    if (currentOverpassMirror === -1) currentOverpassMirror = 0;
                    hideMapStatus();
                    return data;
                } catch(e) {
                    console.warn(`Mirror ${mirror} falhou:`, e.message);
                    continue;
                }
            }
            
            // Todos os mirrors falharam
            showMapStatus('‚ö†Ô∏è Mapa sem dados de rua (offline mode)');
            setTimeout(hideMapStatus, 3000);
            return null;
        }

        function showMapStatus(msg) {
            const el = document.getElementById('map-status');
            el.innerText = msg;
            el.style.display = 'block';
        }
        function hideMapStatus() {
            document.getElementById('map-status').style.display = 'none';
        }

        // ============================================================
        // RESTO DO JOGO (igual ao original, usando as novas fun√ß√µes)
        // ============================================================

        let map;
        const carElement = document.getElementById('car');
        const playerElement = document.getElementById('player');
        const speedElement = document.getElementById('speedometer');
        const instructionsElement = document.getElementById('instructions');
        const titleElement = document.getElementById('game-title');
        const searchElement = document.getElementById('search-container');
        const uiElement = document.getElementById('ui');
        const repUiElement = document.getElementById('reputation-ui');
        const survivalScoreElement = document.getElementById('survival-score');
        const wastedScreenElement = document.getElementById('wasted-screen');
        const wastedReasonElement = document.getElementById('wasted-reason');
        const finalScoreElement = document.getElementById('final-score');
        const restartBtnElement = document.getElementById('restart-btn');
        const carSmokeElement = document.getElementById('car-smoke'); 
        const locNeighElement = document.getElementById('loc-neighborhood');
        const locCityStateElement = document.getElementById('loc-city-state');
        const staminaBarContainer = document.getElementById('stamina-bar-container');
        const staminaBar = document.getElementById('stamina-bar');
        const thoughtBubbleElement = document.getElementById('thought-bubble');
        const loadingTextElement = document.getElementById('loading-text');
        const instructionsText = document.getElementById('instructions-text');

        const btnFullscreen = document.getElementById('btn-fullscreen');
        btnFullscreen.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.warn(`Erro ao tentar tela cheia: ${err.message}`);
                });
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
            }
        });

        const controlSwitch = document.getElementById('control-switch');
        let isTouchMode = false;
        let touchState = { turnLeft: false, turnRight: false, boost: false, brakeExit: false, touches: 0, actionTriggered: false };
        let autoAccelBlockUntil = 0; 

        const textKeyboard = `
            <h3 style="margin-top:0">TECLADO</h3>
            <p><kbd>‚Üë</kbd> <kbd>‚Üì</kbd> <kbd>‚Üê</kbd> <kbd>‚Üí</kbd> : Mover</p>
            <p><kbd>Shift</kbd> : Acelerar+</p>
            <p><kbd>Espa√ßo</kbd> : Entrar/Sair</p>
        `;

        const textTouch = `
            <h3 style="margin-top:0">TELA (AUTO)</h3>
            <p>‚ÜôÔ∏è Inf. Esq. : Vira Esquerda</p>
            <p>‚ÜòÔ∏è Inf. Dir. : Vira Direita</p>
            <p>‚ÜñÔ∏è Sup. Esq. : Turbo / Correr</p>
            <p>‚ÜóÔ∏è Sup. Dir. : Frear (Segure p/ Sair)</p>
        `;

        controlSwitch.addEventListener('change', (e) => {
            isTouchMode = e.target.checked;
            instructionsText.innerHTML = isTouchMode ? textTouch : textKeyboard;
            for(let k in keys) keys[k] = false;
            touchState = { turnLeft: false, turnRight: false, boost: false, brakeExit: false, touches: 0, actionTriggered: false };
        });

        if (('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || window.innerWidth <= 768) {
            controlSwitch.checked = true;
            controlSwitch.dispatchEvent(new Event('change'));
        }

        const keys = {
            ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, Space: false, Shift: false
        };

        function handleTouch(e) {
            if (!isTouchMode) return; 
            
            if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.tagName === 'LABEL' || e.target.tagName === 'SPAN') return;

            if (e.cancelable && e.type !== 'touchend' && e.type !== 'touchcancel') {
                e.preventDefault(); 
            }

            let previousTouches = touchState.touches;
            let touches = e.touches;
            touchState.touches = touches.length;

            if (previousTouches > 0 && touchState.touches === 0) {
                autoAccelBlockUntil = Date.now() + 400; 
            }

            touchState.turnLeft = false;
            touchState.turnRight = false;
            touchState.boost = false;
            touchState.brakeExit = false;

            let w2 = window.innerWidth / 2;
            let h2 = window.innerHeight / 2;

            for (let i = 0; i < touches.length; i++) {
                let t = touches[i];
                let isLeft = t.clientX < w2;
                let isTop = t.clientY < h2;

                if (isTop && isLeft) touchState.boost = true;
                else if (isTop && !isLeft) touchState.brakeExit = true;
                else if (!isTop && isLeft) touchState.turnLeft = true;
                else if (!isTop && !isLeft) touchState.turnRight = true;
            }
            
            if (!touchState.brakeExit) {
                touchState.actionTriggered = false;
            }
        }

        window.addEventListener('touchstart', handleTouch, {passive: false});
        window.addEventListener('touchmove', handleTouch, {passive: false});
        window.addEventListener('touchend', handleTouch, {passive: false});
        window.addEventListener('touchcancel', handleTouch, {passive: false});

        const footL = document.getElementById('player-foot-l');
        const footR = document.getElementById('player-foot-r');
        let walkCycle = 0; 

        let lat = -23.561414;
        let lng = -46.656403;

        let speed = 0;
        let angle = 0; 
        let steering = 0; 
        
        let isDriving = true;
        let carLat = 0, carLng = 0, carAngle = 0;
        let autoWalkToCar = false;

        const baseAcceleration = 0.015; 
        const boostAcceleration = 0.025;
        const baseFriction = 0.985; 
        const brakePower = 0.035;
        const turnSpeed = 3.5; 

        let reputation = 1000;
        let survivalScore = 0; 
        let maxHealth = 100;
        let health = maxHealth;
        let isWasted = false;

        const maxStamina = 1800; 
        let stamina = maxStamina;
        let isExhausted = false;

        let currentInfraction = 'none';
        let infractionFrames = 0;
        const MAX_INFRACTION_FRAMES = 120; 
        let isHitFlashing = false; 

        let buildingPolygons = [];
        let roadSegments = [];
        let envCenterLat = 0;
        let envCenterLng = 0;
        let isFetchingEnvironment = false; 
        let isSpawning = false; 

        let policeCars = [];

        let lastGeoLat = 0;
        let lastGeoLng = 0;

        async function updateLocationName(currentLat, currentLng) {
            const result = await reverseGeocode(currentLat, currentLng);
            if (result) {
                locNeighElement.innerText = "üìç " + result.neighborhood;
                let parts = [];
                if (result.city && result.city !== result.neighborhood) parts.push(result.city);
                if (result.state) parts.push(result.state);
                locCityStateElement.innerText = parts.join(' - ');
            }
        }

        function checkCarVisuals() {
            if (health <= 20 && health > 0) {
                carSmokeElement.classList.add('smoking');
            } else {
                carSmokeElement.classList.remove('smoking');
            }
        }

        function triggerWasted(reason = "") {
            isWasted = true;
            speed = 0;
            autoWalkToCar = false;
            thoughtBubbleElement.style.display = 'none'; 
            infractionFrames = 0;
            
            const wastedTextEl = document.getElementById('wasted-text');
            if (reason === "PRESO!") {
                wastedTextEl.innerText = "PRESO";
                wastedTextEl.style.color = "#2196F3";
            } else {
                wastedTextEl.innerText = "WASTED";
                wastedTextEl.style.color = "#d32f2f";
            }

            if (isDriving) {
                carSmokeElement.classList.remove('smoking'); 
                carElement.style.background = "#222";
                carElement.style.boxShadow = "0 0 50px 30px #ff5722";
            } else {
                document.getElementById('player-body').style.background = "#f44336"; 
            }
            
            wastedReasonElement.innerText = reason;
            finalScoreElement.innerText = Math.floor(survivalScore);
            wastedScreenElement.style.display = "flex";
        }

        async function spawnPlayer(targetLat, targetLng) {
            // Usado ao reiniciar ‚Äî n√£o mostra city-select, vai direto pra cutscene
            isSpawning = true;

            carElement.style.display = 'none';
            playerElement.style.display = 'none';
            uiElement.style.opacity = '0';
            repUiElement.style.opacity = '0';
            searchElement.style.opacity = '0';
            instructionsElement.style.opacity = '0';
            titleElement.style.opacity = '0';
            instructionsElement.style.pointerEvents = 'none';

            await loadEnvironment(targetLat, targetLng, false);

            let snapPt = snapToNearestRoad(targetLat, targetLng);
            lat = snapPt.lat; lng = snapPt.lng;

            if (map) {
                map.setView([lat, lng], 14, { animate: false });
                await flyToZoom(lat, lng, 20, 1.8);
            }

            beginGame();
            isSpawning = false;
        }

        function handleSpacebar() {
            if (isWasted) return;
            
            if (isDriving) {
                const displaySpeed = Math.abs(Math.round(speed * 200));
                if (displaySpeed > 20) {
                    triggerWasted("SAIU DO CARRO EM MOVIMENTO!");
                } else {
                    isDriving = false;
                    carLat = lat; carLng = lng; carAngle = angle;
                    thoughtBubbleElement.style.display = 'none'; 
                    infractionFrames = 0;
                    
                    let leftAngleRad = (angle - 90) * Math.PI / 180;
                    lat += (1.5 * Math.cos(leftAngleRad)) / 111320;
                    lng += (1.5 * Math.sin(leftAngleRad)) / (111320 * Math.cos(lat * Math.PI / 180));
                    speed = 0;
                }
            } else {
                autoWalkToCar = true;
            }
        }

        // ‚îÄ‚îÄ DEBUG OVERLAY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        let debugMode = false;
        const debugSvg = document.getElementById('debug-svg');
        const debugBtn = document.getElementById('debug-btn');

        debugBtn.addEventListener('click', () => {
            debugMode = !debugMode;
            debugSvg.classList.toggle('active', debugMode);
            debugBtn.innerText = debugMode ? 'üîß OCULTAR' : 'üîß DEBUG';
            if (!debugMode) debugSvg.innerHTML = '';
            else drawDebugOverlay();
        });

        function metersToScreen(mx, my) {
            if (!map || envCenterLat === 0) return null;
            const pos = metersToPos(mx, my);
            return map.latLngToContainerPoint([pos.lat, pos.lng]);
        }

        function drawDebugOverlay() {
            if (!debugMode || !map) return;
            debugSvg.innerHTML = '';

            // Roads ‚Äî linhas amarelas
            for (let seg of roadSegments) {
                let a = metersToScreen(seg.v.x, seg.v.y);
                let b = metersToScreen(seg.w.x, seg.w.y);
                if (!a || !b) continue;
                let line = document.createElementNS('http://www.w3.org/2000/svg','line');
                line.setAttribute('x1', a.x); line.setAttribute('y1', a.y);
                line.setAttribute('x2', b.x); line.setAttribute('y2', b.y);
                line.setAttribute('class', 'debug-road');
                debugSvg.appendChild(line);
            }

            // Buildings ‚Äî pol√≠gonos vermelhos
            for (let poly of buildingPolygons) {
                let pts = poly.map(p => {
                    let pm2 = posToMeters(p[1], p[0]);
                    let sc = metersToScreen(pm2.x, pm2.y);
                    return sc ? `${sc.x},${sc.y}` : null;
                }).filter(Boolean).join(' ');
                if (!pts) continue;
                let el = document.createElementNS('http://www.w3.org/2000/svg','polygon');
                el.setAttribute('points', pts);
                el.setAttribute('class', 'debug-building');
                debugSvg.appendChild(el);
            }

            // OBB do jogador ‚Äî caixa verde
            if (envCenterLat !== 0) {
                let pm2 = posToMeters(lat, lng);
                let verts = getOBBVertices(pm2.x, pm2.y, angle);
                let pts = verts.map(v => {
                    let sc = metersToScreen(v.x, v.y);
                    return sc ? `${sc.x},${sc.y}` : null;
                }).filter(Boolean).join(' ');
                if (pts) {
                    let el = document.createElementNS('http://www.w3.org/2000/svg','polygon');
                    el.setAttribute('points', pts);
                    el.setAttribute('class', 'debug-obb');
                    debugSvg.appendChild(el);
                }
            }

            // OBBs dos policiais ‚Äî caixas verdes menores
            for (let p of policeCars) {
                let pm2 = posToMeters(p.lat, p.lng);
                let verts = getOBBVertices(pm2.x, pm2.y, p.angle);
                let pts = verts.map(v => {
                    let sc = metersToScreen(v.x, v.y);
                    return sc ? `${sc.x},${sc.y}` : null;
                }).filter(Boolean).join(' ');
                if (pts) {
                    let el = document.createElementNS('http://www.w3.org/2000/svg','polygon');
                    el.setAttribute('points', pts);
                    el.setAttribute('class', 'debug-obb');
                    el.style.stroke = p.state === 'ram' ? 'orange' : (p.state === 'stunned' ? 'gray' : 'lime');
                    debugSvg.appendChild(el);
                }
            }
        }

        // ‚îÄ‚îÄ CITY SELECT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const citySelect  = document.getElementById('city-select');
        const cutsceneEl  = document.getElementById('cutscene');
        const cutCityName = document.getElementById('cutscene-city-name');
        const cutStatus   = document.getElementById('cutscene-status');
        const cutProgress = document.getElementById('cutscene-progress');
        const cutProgressWrap = document.getElementById('cutscene-progress-wrap');

        // Bot√µes de cidade fixa
        document.querySelectorAll('.city-btn[data-lat]').forEach(btn => {
            btn.addEventListener('click', () => {
                let tLat = parseFloat(btn.dataset.lat);
                let tLng = parseFloat(btn.dataset.lng);
                let name = btn.dataset.name;
                startCutscene(tLat, tLng, name);
            });
        });

        // GPS
        document.getElementById('btn-gps').addEventListener('click', () => {
            if (!navigator.geolocation) { alert('GPS n√£o suportado'); return; }
            navigator.geolocation.getCurrentPosition(pos => {
                startCutscene(pos.coords.latitude, pos.coords.longitude, 'Minha Localiza√ß√£o');
            }, () => { alert('N√£o foi poss√≠vel obter localiza√ß√£o'); });
        });

        // Endere√ßo customizado
        const searchWrap    = document.getElementById('city-search-wrap');
        const searchInput   = document.getElementById('city-search-input');
        const searchResults = document.getElementById('city-search-results');

        document.getElementById('btn-custom').addEventListener('click', () => {
            searchWrap.classList.toggle('visible');
            if (searchWrap.classList.contains('visible')) searchInput.focus();
        });

        let searchDebounce;
        searchInput.addEventListener('input', () => {
            clearTimeout(searchDebounce);
            searchResults.innerHTML = '';
            const q = searchInput.value.trim();
            if (q.length < 3) return;
            searchDebounce = setTimeout(() => doAddressSearch(q), 500);
        });
        searchInput.addEventListener('keydown', e => {
            if (e.key === 'Enter') { clearTimeout(searchDebounce); doAddressSearch(searchInput.value.trim()); }
        });

        async function doAddressSearch(q) {
            searchResults.innerHTML = '<div style="color:#666;font-size:12px;padding:8px">Buscando...</div>';
            try {
                const res = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(q)}&format=json&limit=4`, { headers:{'Accept-Language':'pt-BR'} });
                const data = await res.json();
                searchResults.innerHTML = '';
                if (!data.length) { searchResults.innerHTML = '<div style="color:#666;font-size:12px;padding:8px">Nada encontrado</div>'; return; }
                data.forEach(item => {
                    let btn2 = document.createElement('button');
                    btn2.className = 'search-result-btn';
                    btn2.textContent = item.display_name;
                    btn2.addEventListener('click', () => {
                        startCutscene(parseFloat(item.lat), parseFloat(item.lon), item.display_name.split(',')[0]);
                    });
                    searchResults.appendChild(btn2);
                });
            } catch(e) { searchResults.innerHTML = '<div style="color:#f44;font-size:12px;padding:8px">Erro na busca</div>'; }
        }

        // ‚îÄ‚îÄ CUTSCENE + LOAD ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        async function startCutscene(targetLat, targetLng, cityName) {
            // 1. Esconde sele√ß√£o, mostra cutscene
            citySelect.style.display = 'none';
            cutsceneEl.classList.add('active');
            cutCityName.innerText = cityName;

            // Anima entrada do texto
            await sleep(200);
            cutCityName.style.opacity = '1';
            cutStatus.style.opacity = '1';
            cutProgressWrap.style.opacity = '1';

            setProgress(5, 'Conectando ao mapa...');

            // 2. Inicializa mapa (se ainda n√£o foi)
            if (!map) initMap(targetLat, targetLng);
            else map.setView([targetLat, targetLng], 14, { animate: false });

            setProgress(15, 'Buscando dados da regi√£o...');

            // 3. Carrega dados OSM (ruas + pr√©dios) em raio pequeno
            await loadEnvironment(targetLat, targetLng, false);
            setProgress(55, 'Processando vias...');

            // 4. Snap para a via mais pr√≥xima (ponto real na rua)
            let snapPt = snapToNearestRoad(targetLat, targetLng);
            lat = snapPt.lat; lng = snapPt.lng;
            setProgress(70, 'Posicionando ve√≠culo...');

            // 5. Zoom cinematogr√°fico com o mapa j√° carregado
            await sleep(300);
            setProgress(80, 'Iniciando...');

            map.setView([lat, lng], 14, { animate: false });
            await flyToZoom(lat, lng, 20, 2.2);
            setProgress(100, 'Pronto!');

            await sleep(400);

            // 6. Fecha cutscene e inicia jogo
            cutsceneEl.classList.remove('active');
            debugBtn.classList.add('visible');
            beginGame();
        }

        function setProgress(pct, msg) {
            cutProgress.style.width = pct + '%';
            cutStatus.innerText = msg;
        }

        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        function flyToZoom(toLat, toLng, toZoom, durationSec) {
            return new Promise(resolve => {
                map.flyTo([toLat, toLng], toZoom, { animate: true, duration: durationSec });
                setTimeout(resolve, durationSec * 1000 + 100);
            });
        }

        // Snap para o ponto mais pr√≥ximo em qualquer segmento de rua carregado
        function snapToNearestRoad(tLat, tLng) {
            if (!roadSegments.length) return { lat: tLat, lng: tLng };
            let tm = posToMeters(tLat, tLng);
            let best = null, bestDist = Infinity;

            for (let seg of roadSegments) {
                // Proje√ß√£o do ponto no segmento
                let dx = seg.w.x - seg.v.x, dy = seg.w.y - seg.v.y;
                let len2 = dx*dx + dy*dy;
                let t = len2 > 0 ? Math.max(0, Math.min(1, ((tm.x - seg.v.x)*dx + (tm.y - seg.v.y)*dy) / len2)) : 0;
                let px = seg.v.x + t*dx, py = seg.v.y + t*dy;
                let d = mDist(tm.x, tm.y, px, py);
                if (d < bestDist) { bestDist = d; best = metersToPos(px, py); }
            }
            return best || { lat: tLat, lng: tLng };
        }

        function initMap(cLat, cLng) {
            map = L.map('map', {
                zoomControl: false, keyboard: false, dragging: false,
                scrollWheelZoom: false, doubleClickZoom: false, boxZoom: false,
                touchZoom: false, tap: false
            }).setView([cLat || lat, cLng || lng], 14);

            L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Tiles &copy; Esri', maxZoom: 22, maxNativeZoom: 19
            }).addTo(map);

            requestAnimationFrame(gameLoop);
        }

        function beginGame() {
            speed = 0; angle = 0; steering = 0;
            isDriving = true; autoWalkToCar = false;
            health = maxHealth; isWasted = false;
            reputation = 1000; survivalScore = 0;
            stamina = maxStamina; isExhausted = false;

            carElement.style.display = 'block';
            carElement.style.background = '#d32f2f';
            carElement.style.boxShadow = '0 8px 12px rgba(0,0,0,0.6)';
            playerElement.style.display = 'none';
            uiElement.style.opacity = '1';
            repUiElement.style.opacity = '1';
            searchElement.style.opacity = '1';
            instructionsElement.style.opacity = '1';
            instructionsElement.style.pointerEvents = 'auto';
            titleElement.style.opacity = '1';

            checkCarVisuals();
            for (let k in keys) keys[k] = false;
        }

        window.onload = () => {
            // S√≥ mostra a tela de sele√ß√£o ‚Äî n√£o inicializa mapa ainda
            citySelect.style.display = 'flex';
        };

        function toMeters(pLat, pLng) {
            const x = (pLng - envCenterLng) * 111320 * Math.cos(envCenterLat * Math.PI / 180);
            const y = (pLat - envCenterLat) * 111320;
            return { x, y };
        }

        function sqr(x) { return x * x; }
        function dist2(v, w) { return sqr(v.x - w.x) + sqr(v.y - w.y); }
        function distToSegmentSquared(p, v, w) {
            let l2 = dist2(v, w);
            if (l2 === 0) return dist2(p, v);
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            return dist2(p, { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) });
        }
        function distToSegment(p, v, w) { return Math.sqrt(distToSegmentSquared(p, v, w)); }

        function isPointInPolygon(point, vs) {
            let x = point[0], y = point[1];
            let inside = false;
            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                let xi = vs[i][0], yi = vs[i][1];
                let xj = vs[j][0], yj = vs[j][1];
                let intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        async function loadEnvironment(centerLat, centerLng, snapToRoad = false) {
            if (isFetchingEnvironment) return; 
            isFetchingEnvironment = true;

            // Raio inicial menor (200m) = query r√°pida e leve ao spawnar
            // Reload enquanto joga usa 300m para ter margem de seguran√ßa
            const radius = snapToRoad ? 200 : 300;
            const query = `[out:json][timeout:12];
            (
              way["building"](around:${radius},${centerLat},${centerLng});
              way["highway"]["highway"!~"footway|pedestrian|path|steps|cycleway"](around:${radius},${centerLat},${centerLng});
            );
            out tags geom;`;

            try {
                const data = await fetchOverpass(query);

                if (data && data.elements) {
                    buildingPolygons = [];
                    roadSegments = [];
                    envCenterLat = centerLat;
                    envCenterLng = centerLng;

                    if (snapToRoad) {
                        for (let el of data.elements) {
                            if (el.type === "way" && el.tags && el.tags.highway && el.geometry && el.geometry.length > 0) {
                                lat = el.geometry[0].lat;
                                lng = el.geometry[0].lon;
                                break;
                            }
                        }
                    }

                    data.elements.forEach(el => {
                        if (el.type === "way" && el.geometry) {
                            if (el.tags && el.tags.building) {
                                const polyForMath = el.geometry.map(g => [g.lon, g.lat]); 
                                buildingPolygons.push(polyForMath);
                            } else if (el.tags && el.tags.highway) {
                                let isOneway = 0;
                                if (el.tags.oneway === "yes" || el.tags.oneway === "1" || el.tags.oneway === "true") isOneway = 1;
                                if (el.tags.oneway === "-1") isOneway = -1;
                                let isHighway = /motorway|trunk/i.test(el.tags.highway);

                                for (let i = 0; i < el.geometry.length - 1; i++) {
                                    let p1 = el.geometry[i];
                                    let p2 = el.geometry[i+1];
                                    roadSegments.push({
                                        v: toMeters(p1.lat, p1.lon), w: toMeters(p2.lat, p2.lon), oneway: isOneway, isHighway: isHighway
                                    });
                                }
                            }
                        }
                    });
                }
            } catch (err) {
                console.warn('Erro ao carregar ambiente:', err);
            }
            isFetchingEnvironment = false; 
        }

        window.addEventListener('keydown', (e) => {
            if (document.activeElement.tagName === 'INPUT') return;
            
            if (e.key === 'Shift') keys.Shift = true;

            if (e.code === 'Space') {
                e.preventDefault(); 
                if (!keys.Space) { keys.Space = true; handleSpacebar(); }
            } else if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = true;
            }
        });

        window.addEventListener('keyup', (e) => {
            if (e.key === 'Shift') keys.Shift = false;

            if (e.code === 'Space') {
                keys.Space = false;
            } else if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = false;
            }
        });

        restartBtnElement.addEventListener('click', () => {
            isWasted = false;
            reputation = 1000;
            survivalScore = 0;
            stamina = maxStamina;
            isExhausted = false;
            infractionFrames = 0;
            currentInfraction = 'none';
            
            wastedScreenElement.style.display = "none";
            wastedReasonElement.innerText = "";
            
            carElement.style.background = "#d32f2f";
            carElement.style.boxShadow = "0 8px 12px rgba(0,0,0,0.6)";
            document.getElementById('player-body').style.background = "#FFD700";
            checkCarVisuals();

            policeCars.forEach(p => p.element.remove());
            policeCars = [];

            spawnPlayer(lat, lng);
            
            requestAnimationFrame(gameLoop);
        });

        document.getElementById('search-btn').addEventListener('click', async () => {
            const query = document.getElementById('address-input').value;
            if (!query) return;

            const btn = document.getElementById('search-btn');
            btn.innerText = '...'; 

            const result = await geocodeAddress(query);
            
            if (result) {
                btn.innerText = 'Buscar';
                lat = result.lat;
                lng = result.lng;
                spawnPlayer(result.lat, result.lng); 
            } else {
                btn.innerText = 'N√£o achou!';
                setTimeout(() => btn.innerText = 'Buscar', 2000);
            }
        });

        // Busca com Enter
        document.getElementById('address-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') document.getElementById('search-btn').click();
        });

        let lastTime = performance.now();
        let accumulator = 0;
        const TIME_STEP = 16.666;

        // ============================================================
        // SISTEMA DE POL√çCIA ‚Äî F√çSICA COM SEPARA√á√ÉO DE CORPOS REAL
        //
        // Cada corpo tem raio R em metros. A cada frame:
        //   1. Cada viatura resolve sua IA e calcula pr√≥xima posi√ß√£o (nextLat/nextLng)
        //   2. FASE DE SEPARA√á√ÉO:
        //      a) policiais vs policiais  ‚Üí empurra ambos para fora da sobreposi√ß√£o
        //         e troca componentes de velocidade ao longo do eixo de colis√£o
        //      b) policiais vs jogador    ‚Üí mesma l√≥gica, com dano/preso conforme estado
        //   3. S√≥ a√≠ a posi√ß√£o √© confirmada
        //
        // Estados da IA:
        //   'chase'   ‚Üí persegui√ß√£o normal, mant√©m 12-30 m de dist√¢ncia
        //   'ram'     ‚Üí investida diagonal (offset lateral deliberado)
        //   'avoid'   ‚Üí logo ap√≥s rasp√£o, abre caminho para n√£o bater de frente
        //   'stunned' ‚Üí tonto ap√≥s colis√£o, desacelera e n√£o toma decis√µes
        // ============================================================

        // ============================================================
        // HITBOX RETANGULAR (OBB ‚Äî Oriented Bounding Box)
        // Cada carro tem: largura W=4m, comprimento L=8m
        // Colis√£o OBB vs OBB via SAT (Separating Axis Theorem) simplificado
        // ============================================================
        const CAR_W = 1.8;   // metade da largura  (total ~3.6m ‚Äî casa com 14px no zoom 20)
        const CAR_L = 3.2;   // metade do comprimento (total ~6.4m ‚Äî casa com 28px no zoom 20)

        // Retorna os 4 v√©rtices do OBB de um carro (posi√ß√£o em metros, √¢ngulo em graus)
        function getOBBVertices(cx, cy, angleDeg) {
            const a = angleDeg * Math.PI / 180;
            const cos = Math.cos(a), sin = Math.sin(a);
            // Eixos locais: frente/tr√°s = sin/cos, direita/esquerda = cos/-sin
            return [
                { x: cx + sin * CAR_L  + cos * CAR_W,  y: cy + cos * CAR_L  - sin * CAR_W  },
                { x: cx + sin * CAR_L  - cos * CAR_W,  y: cy + cos * CAR_L  + sin * CAR_W  },
                { x: cx - sin * CAR_L  - cos * CAR_W,  y: cy - cos * CAR_L  + sin * CAR_W  },
                { x: cx - sin * CAR_L  + cos * CAR_W,  y: cy - cos * CAR_L  - sin * CAR_W  },
            ];
        }

        // Projeta um array de v√©rtices num eixo e retorna [min, max]
        function projectOBB(verts, axX, axY) {
            let mn = Infinity, mx = -Infinity;
            for (let v of verts) {
                let p = v.x * axX + v.y * axY;
                if (p < mn) mn = p;
                if (p > mx) mx = p;
            }
            return [mn, mx];
        }

        // SAT entre dois OBBs. Retorna {overlap, nx, ny} ou null se separados.
        // nx,ny = eixo de menor penetra√ß√£o, apontando de A para B.
        function obbSAT(axA, ayA, angA, axB, ayB, angB) {
            const vA = getOBBVertices(axA, ayA, angA);
            const vB = getOBBVertices(axB, ayB, angB);

            // 4 eixos: 2 de cada OBB
            const aRad = angA * Math.PI / 180;
            const bRad = angB * Math.PI / 180;
            const axes = [
                {  x: Math.sin(aRad),  y: Math.cos(aRad)  },
                {  x: Math.cos(aRad),  y: -Math.sin(aRad) },
                {  x: Math.sin(bRad),  y: Math.cos(bRad)  },
                {  x: Math.cos(bRad),  y: -Math.sin(bRad) },
            ];

            let minOverlap = Infinity, minAxis = null;
            for (let ax of axes) {
                let [mnA, mxA] = projectOBB(vA, ax.x, ax.y);
                let [mnB, mxB] = projectOBB(vB, ax.x, ax.y);
                let overlap = Math.min(mxA, mxB) - Math.max(mnA, mnB);
                if (overlap <= 0) return null; // eixo separador encontrado
                if (overlap < minOverlap) {
                    minOverlap = overlap;
                    // Garante que nx,ny aponta de A para B
                    let sign = (axB - axA) * ax.x + (ayB - ayA) * ax.y >= 0 ? 1 : -1;
                    minAxis = { x: ax.x * sign, y: ax.y * sign };
                }
            }
            return { overlap: minOverlap, nx: minAxis.x, ny: minAxis.y };
        }

        // Resolve colis√£o OBB el√°stica.
        // Recebe centros, velocidades (m/frame) e √¢ngulos.
        // Retorna novas posi√ß√µes e velocidades.
        function resolveOBBCollision(ax, ay, avx, avy, angA,
                                     bx, by, bvx, bvy, angB,
                                     restitution = 0.5) {
            const col = obbSAT(ax, ay, angA, bx, by, angB);
            if (!col) return null;

            const { overlap, nx, ny } = col;

            // Separa os corpos (metade cada)
            const sep = overlap / 2 + 0.05;
            ax -= nx * sep;  ay -= ny * sep;
            bx += nx * sep;  by += ny * sep;

            // Impulso ao longo do eixo de colis√£o
            const dvx = avx - bvx, dvy = avy - bvy;
            const dot  = dvx * nx + dvy * ny;
            if (dot > 0) {
                const imp = dot * (1 + restitution) / 2;
                avx -= imp * nx;  avy -= imp * ny;
                bvx += imp * nx;  bvy += imp * ny;
            }
            return { ax, ay, avx, avy, bx, by, bvx, bvy };
        }

        // Ponto no interior de um OBB (para teste vs pr√©dios)
        function pointInOBB(px, py, cx, cy, angleDeg) {
            const a = -angleDeg * Math.PI / 180; // inverso para espa√ßo local
            const dx = px - cx, dy = py - cy;
            const lx = dx * Math.cos(a) - dy * Math.sin(a);
            const ly = dx * Math.sin(a) + dy * Math.cos(a);
            return Math.abs(lx) <= CAR_W && Math.abs(ly) <= CAR_L;
        }

        // Retorna os limites vis√≠veis do mapa em graus (com margem)
        function getScreenBounds(margin = 20) {
            if (!map) return null;
            const b = map.getBounds();
            return {
                minLat: b.getSouth() - margin / 111320,
                maxLat: b.getNorth() + margin / 111320,
                minLng: b.getWest()  - margin / (111320 * Math.cos(lat * Math.PI / 180)),
                maxLng: b.getEast()  + margin / (111320 * Math.cos(lat * Math.PI / 180)),
            };
        }

        function isOffScreen(pLat, pLng) {
            const b = getScreenBounds(5);
            if (!b) return true;
            return pLat < b.minLat || pLat > b.maxLat || pLng < b.minLng || pLng > b.maxLng;
        }

        function spawnPolice() {
            // Encontra segmentos de rua que estejam FORA da tela (margin = 15px al√©m da borda)
            // e a uma dist√¢ncia razo√°vel do jogador (50-350m)
            const pm = posToMeters(lat, lng);
            const bounds = getScreenBounds(0);

            let candidates = [];

            if (roadSegments.length > 0) {
                for (let seg of roadSegments) {
                    let midX = (seg.v.x + seg.w.x) / 2;
                    let midY = (seg.v.y + seg.w.y) / 2;
                    let d    = mDist(midX, midY, pm.x, pm.y);
                    if (d < 50 || d > 350) continue;

                    // Converte para lat/lng para testar se est√° fora da tela
                    let dest = metersToPos(midX, midY);
                    if (bounds && dest.lat > bounds.minLat && dest.lat < bounds.maxLat &&
                                  dest.lng > bounds.minLng && dest.lng < bounds.maxLng) continue;

                    candidates.push({ seg, midX, midY, d });
                }
            }

            // Ordena por dist√¢ncia e sorteia entre os mais pr√≥ximos
            candidates.sort((a, b) => a.d - b.d);
            let pool = candidates.slice(0, Math.min(8, candidates.length));

            let pLat, pLng, pAngle;
            if (pool.length > 0) {
                let c = pool[Math.floor(Math.random() * pool.length)];
                let dest = metersToPos(c.midX, c.midY);
                pLat   = dest.lat;
                pLng   = dest.lng;
                pAngle = Math.atan2(c.seg.w.x - c.seg.v.x, c.seg.w.y - c.seg.v.y) * 180 / Math.PI;
            } else {
                // Fallback: nasce num √¢ngulo aleat√≥rio a exatamente 280m, fora da tela
                let spawnAngle = Math.random() * Math.PI * 2;
                pLat   = lat + 280 * Math.cos(spawnAngle) / 111320;
                pLng   = lng + 280 * Math.sin(spawnAngle) / (111320 * Math.cos(lat * Math.PI / 180));
                pAngle = spawnAngle * 180 / Math.PI + 180;
            }

            let el = document.createElement('div');
            el.className = 'police-car';
            let roof = document.createElement('div');
            roof.className = 'police-roof';
            let siren = document.createElement('div');
            siren.className = 'siren';
            roof.appendChild(siren);
            el.appendChild(roof);
            document.body.appendChild(el);

            policeCars.push({
                lat: pLat, lng: pLng,
                angle: pAngle,
                speed: 0.05,
                vx: 0, vy: 0,
                element: el,
                state: 'chase',
                stateTimer: 0,
                ramCooldown: 0,
                policeCooldown: 0,
                ramOffsetSign: 1,
                stuckTimer: 0,
                lastLat: pLat, lastLng: pLng,
            });
        }

        // ‚îÄ‚îÄ Helpers de posi√ß√£o (usados tamb√©m fora da pol√≠cia) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function posToMeters(pLat, pLng) {
            return {
                x: (pLng - envCenterLng) * 111320 * Math.cos(envCenterLat * Math.PI / 180),
                y: (pLat - envCenterLat) * 111320
            };
        }
        function metersToPos(mx, my) {
            return {
                lat: envCenterLat + my / 111320,
                lng: envCenterLng + mx / (111320 * Math.cos(envCenterLat * Math.PI / 180))
            };
        }
        function mDist(ax, ay, bx, by) { return Math.sqrt((ax-bx)**2 + (ay-by)**2); }

        // Testa OBB do carro contra todos os pr√©dios (4 v√©rtices + centro)
        function obbHitsBuilding(cx, cy, angleDeg) {
            if (!buildingPolygons.length) return false;
            const verts = getOBBVertices(cx, cy, angleDeg);
            // Tamb√©m inclui o centro como ponto de teste
            const pts = [...verts, { x: cx, y: cy }];
            for (let poly of buildingPolygons) {
                for (let v of pts) {
                    let pos = metersToPos(v.x, v.y);
                    if (isPointInPolygon([pos.lng, pos.lat], poly)) return true;
                }
            }
            return false;
        }

        function updatePoliceAI(stars) {
            if (policeCars.length === 0) return;

            const baseSpd   = 0.45 + stars * 0.08;
            const chaseTurn = 2.8  + stars * 0.2;
            const RAM_DIST  = 28;

            const pm   = posToMeters(lat, lng);
            const pRad = angle * Math.PI / 180;
            const pvx  = speed * Math.sin(pRad);
            const pvy  = speed * Math.cos(pRad);

            // Remove muito distantes
            policeCars = policeCars.filter(p => {
                let cm = posToMeters(p.lat, p.lng);
                if (mDist(cm.x, cm.y, pm.x, pm.y) > 480) { p.element.remove(); return false; }
                return true;
            });

            // ‚îÄ‚îÄ FASE 1: IA ‚Üí posi√ß√£o candidata em metros ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            let next = policeCars.map(p => {
                if (p.stateTimer > 0)     p.stateTimer--;
                if (p.ramCooldown > 0)    p.ramCooldown--;
                if (p.policeCooldown > 0) p.policeCooldown--;

                let cm = posToMeters(p.lat, p.lng);
                let dp = mDist(cm.x, cm.y, pm.x, pm.y);

                // Anti-stuck
                p.stuckTimer++;
                if (p.stuckTimer >= 120) {
                    let lm = posToMeters(p.lastLat, p.lastLng);
                    if (mDist(cm.x, cm.y, lm.x, lm.y) < 2) {
                        p.angle += 90 + Math.random() * 60;
                        p.speed  = baseSpd * 0.5;
                        if (p.state !== 'ram') p.state = 'chase';
                    }
                    p.stuckTimer = 0; p.lastLat = p.lat; p.lastLng = p.lng;
                }

                if (p.state === 'stunned') {
                    p.speed *= 0.85;
                    if (p.stateTimer <= 0) p.state = 'chase';

                } else if (p.state === 'chase') {
                    let tA = Math.atan2(pm.x - cm.x, pm.y - cm.y) * 180 / Math.PI;
                    let df = tA - p.angle; while (df > 180) df -= 360; while (df < -180) df += 360;
                    p.angle += Math.max(-chaseTurn, Math.min(chaseTurn, df * 0.18));
                    let tS = dp > 60 ? baseSpd * 1.6 : baseSpd * (0.9 + Math.abs(speed) * 0.5);
                    p.speed += (tS - p.speed) * 0.035;
                    p.speed  = Math.max(-0.1, Math.min(tS * 1.1, p.speed));
                    if (dp < RAM_DIST && p.ramCooldown <= 0 && p.policeCooldown <= 0 && isDriving) {
                        p.state = 'ram'; p.stateTimer = 80 + stars * 10;
                        p.ramOffsetSign = Math.random() > 0.5 ? 1 : -1;
                    }

                } else if (p.state === 'ram') {
                    let bA = Math.atan2(pm.x - cm.x, pm.y - cm.y) * 180 / Math.PI;
                    let tA = bA + p.ramOffsetSign * Math.max(4, 20 - dp * 0.5);
                    let df = tA - p.angle; while (df > 180) df -= 360; while (df < -180) df += 360;
                    p.angle += Math.max(-chaseTurn*1.5, Math.min(chaseTurn*1.5, df * 0.28));
                    let rS = baseSpd * (1.3 + stars * 0.1);
                    p.speed += (rS - p.speed) * 0.07; p.speed = Math.min(rS, p.speed);
                    if (p.stateTimer <= 0) { p.state = 'chase'; p.ramCooldown = 150 + Math.random()*60; }

                } else if (p.state === 'avoid') {
                    let bA = Math.atan2(pm.x - cm.x, pm.y - cm.y) * 180 / Math.PI;
                    let tA = bA - p.ramOffsetSign * (50 + Math.random() * 20);
                    let df = tA - p.angle; while (df > 180) df -= 360; while (df < -180) df += 360;
                    p.angle += Math.max(-4, Math.min(4, df * 0.2));
                    p.speed *= 0.97;
                    if (p.stateTimer <= 0) p.state = 'chase';
                }

                let rad = p.angle * Math.PI / 180;
                p.vx = p.speed * Math.sin(rad);
                p.vy = p.speed * Math.cos(rad);
                return { x: cm.x + p.vx, y: cm.y + p.vy };
            });

            // ‚îÄ‚îÄ FASE 2a: OBB pol√≠cia vs pol√≠cia ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            for (let i = 0; i < policeCars.length; i++) {
                for (let j = i + 1; j < policeCars.length; j++) {
                    let pi = policeCars[i], pj = policeCars[j];
                    let ni = next[i], nj = next[j];
                    let r = resolveOBBCollision(
                        ni.x, ni.y, pi.vx, pi.vy, pi.angle,
                        nj.x, nj.y, pj.vx, pj.vy, pj.angle, 0.5
                    );
                    if (!r) continue;
                    ni.x = r.ax; ni.y = r.ay; pi.vx = r.avx; pi.vy = r.avy;
                    nj.x = r.bx; nj.y = r.by; pj.vx = r.bvx; pj.vy = r.bvy;
                    pi.speed = Math.hypot(pi.vx, pi.vy) * (pi.speed < 0 ? -1 : 1);
                    pj.speed = Math.hypot(pj.vx, pj.vy) * (pj.speed < 0 ? -1 : 1);
                    let imp  = mDist(pi.vx, pi.vy, pj.vx, pj.vy);
                    let stun = Math.round(30 + imp * 80);
                    pi.state = 'stunned'; pi.stateTimer = stun; pi.policeCooldown = 50;
                    pj.state = 'stunned'; pj.stateTimer = stun; pj.policeCooldown = 50;
                }
            }

            // ‚îÄ‚îÄ FASE 2b: OBB pol√≠cia vs jogador ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            if (isDriving && !isWasted) {
                for (let i = 0; i < policeCars.length; i++) {
                    let p = policeCars[i], np = next[i];
                    let r = resolveOBBCollision(
                        pm.x, pm.y, pvx,  pvy,  angle,
                        np.x, np.y, p.vx, p.vy, p.angle, 0.45
                    );
                    if (!r) continue;

                    np.x = r.bx; np.y = r.by; p.vx = r.bvx; p.vy = r.bvy;
                    p.speed = Math.hypot(p.vx, p.vy) * (p.speed < 0 ? -1 : 1);

                    let nS = Math.hypot(r.avx, r.avy);
                    speed = nS * ((r.avx*pvx + r.avy*pvy) >= 0 ? 1 : -1);
                    if (nS > 0.01) angle = Math.atan2(r.avx, r.avy) * 180 / Math.PI;

                    if (p.state === 'ram') {
                        health -= 7 + stars; reputation -= 4;
                        p.state = 'avoid'; p.stateTimer = 45;
                        p.ramCooldown = 130 + Math.random() * 50;
                    } else {
                        if (Math.abs(speed) < 0.04) { triggerWasted("PRESO!"); return; }
                        health -= 3; reputation -= 2;
                        p.state = 'stunned'; p.stateTimer = 40;
                    }
                    checkCarVisuals();
                    if (health <= 0) { triggerWasted("CARRO DESTRU√çDO!"); return; }
                    statusColor = "#2196F3"; isHitFlashing = true;
                    carElement.style.background = "#2196F3";
                    carElement.style.boxShadow  = "0 0 20px 10px #2196F3";
                    setTimeout(() => {
                        isHitFlashing = false;
                        if (!isWasted && isDriving) carElement.style.background = "#d32f2f";
                    }, 180);
                }
            }

            // Captura a p√©
            if (!isDriving && !isWasted) {
                for (let i = 0; i < policeCars.length; i++) {
                    let cm = posToMeters(policeCars[i].lat, policeCars[i].lng);
                    if (mDist(cm.x, cm.y, pm.x, pm.y) < 3.5 && policeCars[i].state !== 'stunned') {
                        triggerWasted("PRESO!"); return;
                    }
                }
            }

            // ‚îÄ‚îÄ FASE 3: confirma posi√ß√£o, OBB vs pr√©dio ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            for (let i = 0; i < policeCars.length; i++) {
                let p = policeCars[i], np = next[i];
                if (obbHitsBuilding(np.x, np.y, p.angle)) {
                    p.speed *= -0.35; p.vx *= -0.35; p.vy *= -0.35;
                    p.angle += (Math.random() > 0.5 ? 1 : -1) * (20 + Math.random() * 25);
                    p.state = 'stunned'; p.stateTimer = 50;
                } else {
                    let dest = metersToPos(np.x, np.y);
                    p.lat = dest.lat; p.lng = dest.lng;
                }
            }
        }

        function gameLoop(currentTime) {
            requestAnimationFrame(gameLoop);

            if (isWasted || isSpawning) return;

            if (!currentTime) currentTime = performance.now();
            let dt = currentTime - lastTime;
            lastTime = currentTime;
            
            if (dt > 100) dt = 100;
            accumulator += dt;

            while (accumulator >= TIME_STEP) {
                updatePhysics();
                accumulator -= TIME_STEP;
            }

            updateRender();
        }

        let statusColor = "white";

        function updatePhysics() {
            if (isTouchMode && !autoWalkToCar) {
                keys.ArrowLeft = touchState.turnLeft;
                keys.ArrowRight = touchState.turnRight;

                if (touchState.brakeExit) {
                    keys.ArrowUp = false;
                    keys.ArrowDown = true;
                    keys.Shift = false;
                    
                    const displaySpeed = Math.abs(Math.round(speed * 200));
                    if (!touchState.actionTriggered) {
                        if (isDriving && displaySpeed <= 15) {
                            handleSpacebar(); 
                            touchState.actionTriggered = true;
                        } else if (!isDriving) {
                            handleSpacebar(); 
                            touchState.actionTriggered = true;
                        }
                    }
                } else {
                    if (Date.now() > autoAccelBlockUntil) keys.ArrowUp = true; 
                    else keys.ArrowUp = false; 
                    
                    keys.ArrowDown = false;
                    keys.Shift = touchState.boost;
                }
            }

            if (!isFetchingEnvironment && envCenterLat !== 0) {
                let distToCenter = Math.sqrt(Math.pow((lat - envCenterLat) * 111320, 2) + Math.pow((lng - envCenterLng) * 111320 * Math.cos(envCenterLat * Math.PI / 180), 2));
                if (distToCenter > 350) loadEnvironment(lat, lng);
            }

            let distSinceLastGeo = Math.sqrt(Math.pow((lat - lastGeoLat) * 111320, 2) + Math.pow((lng - lastGeoLng) * 111320 * Math.cos(lat * Math.PI / 180), 2));
            if (lastGeoLat === 0 || distSinceLastGeo > 150) {
                lastGeoLat = lat; lastGeoLng = lng; updateLocationName(lat, lng);
            }

            let carMeters = toMeters(lat, lng);
            let onRoad = false;
            let closestSeg = null;
            let minDist = Infinity;
            const roadWidth = 12; 
            
            if (roadSegments.length > 0) {
                for (let seg of roadSegments) {
                    let d = distToSegment(carMeters, seg.v, seg.w);
                    if (d < minDist) { minDist = d; closestSeg = seg; }
                }
                if (minDist < roadWidth) onRoad = true;
            } else { onRoad = true; }

            let currentMaxSpeed, currentFriction, currentTurnSpeed, currentAccel;
            statusColor = "white";
            let isSprinting = false;

            let baseRoadLimit = onRoad && closestSeg ? (closestSeg.isHighway ? 1.0 : 0.5) : 0.2; 

            if (isDriving) {
                let damageMultiplier = (health <= 20) ? 0.5 : 1.0;

                if (keys.Shift) currentMaxSpeed = 1.1 * damageMultiplier; 
                else currentMaxSpeed = baseRoadLimit * damageMultiplier; 
                
                currentFriction = onRoad ? baseFriction : 0.82; 
                currentTurnSpeed = onRoad ? turnSpeed : turnSpeed * 0.6;
                currentAccel = (keys.Shift ? boostAcceleration : baseAcceleration) * damageMultiplier; 
                
                staminaBarContainer.style.display = 'none'; 

            } else {
                let isMoving = keys.ArrowUp || keys.ArrowDown || keys.ArrowLeft || keys.ArrowRight;
                staminaBarContainer.style.display = 'block';

                if (keys.Shift && !isExhausted && isMoving) {
                    isSprinting = true;
                    currentMaxSpeed = 0.15; 
                    stamina -= 1; 
                    if (stamina <= 0) { stamina = 0; isExhausted = true; }
                } else {
                    isSprinting = false;
                    currentMaxSpeed = 0.075; 
                    if (!isMoving) stamina += 6; else stamina += 3; 
                    if (stamina >= maxStamina) { stamina = maxStamina; isExhausted = false; }
                }

                staminaBar.style.width = (stamina / maxStamina * 100) + '%';
                staminaBar.style.backgroundColor = isExhausted ? '#f44336' : '#2196F3';

                currentFriction = 0.8; 
                currentTurnSpeed = 8.0; 
                currentAccel = isSprinting ? 0.04 : 0.02; 
            }

            let isOffRoad = false, isWrongWay = false, isSpeeding = false, isDrivingWell = false;

            if (isDriving && Math.abs(speed) > 0.05) {
                if (!onRoad) {
                    reputation -= 1.5; statusColor = "#f44336"; isOffRoad = true;
                    health -= 0.05; checkCarVisuals(); 
                    if (health <= 0 && !isWasted) triggerWasted("SUSPENS√ÉO DESTRU√çDA!");
                } else if (closestSeg) {
                    let Rx = closestSeg.w.x - closestSeg.v.x;
                    let Ry = closestSeg.w.y - closestSeg.v.y;
                    let R_len = Math.sqrt(Rx*Rx + Ry*Ry);

                    let radV = angle * Math.PI / 180;
                    let Vx = Math.sin(radV) * speed;
                    let Vy = Math.cos(radV) * speed;
                    let V_len = Math.abs(speed);

                    let Cx = carMeters.x - closestSeg.v.x;
                    let Cy = carMeters.y - closestSeg.v.y;

                    if (R_len > 0 && V_len > 0) {
                        let dotProduct = (Rx * Vx + Ry * Vy); 
                        let crossProduct = (Rx * Cy - Ry * Cx); 
                        let alignment = Math.abs(dotProduct) / (R_len * V_len);
                        
                        if (alignment > 0.4) { 
                            let signedDist = crossProduct / R_len; 
                            let isMovingForward = dotProduct > 0;

                            if (closestSeg.oneway !== 0) {
                                let correctDir = closestSeg.oneway === 1 ? isMovingForward : !isMovingForward;
                                if (correctDir) { reputation += 0.2; statusColor = "#4CAF50"; isDrivingWell = true; } 
                                else { reputation -= 2.0; statusColor = "#f44336"; isWrongWay = true; }
                            } else {
                                let isRightSide = signedDist < -1.5; 
                                let isLeftSide = signedDist > 1.5;
                                if ((isMovingForward && isRightSide) || (!isMovingForward && isLeftSide)) {
                                    reputation += 0.2; statusColor = "#4CAF50"; isDrivingWell = true;
                                } else if ((isMovingForward && isLeftSide) || (!isMovingForward && isRightSide)) {
                                    reputation -= 1.0; statusColor = "#ff9800"; isWrongWay = true;
                                } else { statusColor = "#ffeb3b"; }
                            }
                        } else { statusColor = "white"; }
                    }
                }
                
                if (onRoad && Math.abs(speed) > baseRoadLimit + 0.05) {
                    reputation -= 0.05; statusColor = "#ff9800"; 
                    isSpeeding = true; isDrivingWell = false; 
                }
            }

            if (isDriving && Math.abs(speed) > 0.05) {
                if (isOffRoad) currentInfraction = 'offroad';
                else if (isWrongWay) currentInfraction = 'wrongway';
                else if (isSpeeding) currentInfraction = 'speeding';
                else currentInfraction = 'none';
            } else { currentInfraction = 'none'; }

            if (currentInfraction !== 'none') {
                infractionFrames++;
                if (infractionFrames > MAX_INFRACTION_FRAMES) infractionFrames = MAX_INFRACTION_FRAMES;
            } else {
                infractionFrames -= 2; 
                if (infractionFrames < 0) infractionFrames = 0;
            }

            if (!autoWalkToCar) {
                let isTurningIntent = keys.ArrowLeft || keys.ArrowRight;
                
                if (isDriving && isTurningIntent) currentAccel *= 0.2;

                if (keys.ArrowUp) speed += currentAccel;
                let currentBrake = isDriving ? brakePower * (health <= 20 ? 0.5 : 1.0) : currentAccel;
                if (keys.ArrowDown) speed -= currentBrake; 

                speed *= currentFriction;

                if (isDriving && !onRoad && Math.abs(speed) > currentMaxSpeed) { speed *= 0.85; }

                if (Math.abs(speed) > 0.01) {
                    const turnDirection = speed > 0 ? 1 : -1;
                    
                    let steerSpeed = isTouchMode ? 0.08 : 0.25; 
                    
                    if (keys.ArrowLeft) steering -= steerSpeed; 
                    else if (keys.ArrowRight) steering += steerSpeed; 
                    else steering *= 0.5; 
                    
                    steering = Math.max(-1, Math.min(1, steering));
                    angle += currentTurnSpeed * steering * turnDirection;
                }

                if (speed > currentMaxSpeed) speed = currentMaxSpeed;
                if (speed < -currentMaxSpeed / 2) speed = -currentMaxSpeed / 2;

                if (isDriving && onRoad && closestSeg && !isTurningIntent && Math.abs(speed) > 0.1) {
                    let Rx = closestSeg.w.x - closestSeg.v.x;
                    let Ry = closestSeg.w.y - closestSeg.v.y;
                    let R_len = Math.sqrt(Rx*Rx + Ry*Ry);

                    if (R_len > 0) {
                        let radV = angle * Math.PI / 180;
                        let Vx = Math.sin(radV); let Vy = Math.cos(radV);
                        let dotProduct = (Rx * Vx + Ry * Vy);

                        let targetRx = dotProduct > 0 ? Rx : -Rx;
                        let targetRy = dotProduct > 0 ? Ry : -Ry;

                        let targetAngle = Math.atan2(targetRx, targetRy) * 180 / Math.PI;

                        let diffAngle = targetAngle - angle;
                        while (diffAngle > 180) diffAngle -= 360;
                        while (diffAngle < -180) diffAngle += 360;

                        if (Math.abs(diffAngle) < 15) { 
                            angle += diffAngle * 0.06;

                            let l2 = R_len * R_len;
                            let t = ((carMeters.x - closestSeg.v.x) * Rx + (carMeters.y - closestSeg.v.y) * Ry) / l2;
                            t = Math.max(0, Math.min(1, t));
                            
                            let targetPx = closestSeg.v.x + t * Rx;
                            let targetPy = closestSeg.v.y + t * Ry;

                            if (closestSeg.oneway === 0) {
                                let nx = Rx / R_len; let ny = Ry / R_len;
                                let offsetDist = 2.0; 
                                if (dotProduct > 0) { targetPx += ny * offsetDist; targetPy += -nx * offsetDist; } 
                                else { targetPx += -ny * offsetDist; targetPy += nx * offsetDist; }
                            }

                            let pullFactor = 0.05 * Math.abs(speed); 
                            if (pullFactor > 0.12) pullFactor = 0.12;
                            
                            let dX = targetPx - carMeters.x;
                            let dY = targetPy - carMeters.y;
                            
                            lat += (dY * pullFactor) / 111320;
                            lng += (dX * pullFactor) / (111320 * Math.cos(lat * Math.PI / 180));
                        }
                    }
                }

            } else {
                let dLng = carLng - lng;
                let dLat = carLat - lat;
                let distMeters = Math.sqrt(Math.pow(dLat * 111320, 2) + Math.pow(dLng * 111320 * Math.cos(lat * Math.PI / 180), 2));
                
                if (distMeters < 2.0) {
                    isDriving = true; autoWalkToCar = false;
                    lat = carLat; lng = carLng; angle = carAngle; speed = 0;
                } else {
                    let targetAngleRad = Math.atan2(dLng * Math.cos(lat * Math.PI / 180), dLat);
                    angle = targetAngleRad * 180 / Math.PI;
                    speed = (!isExhausted && stamina > 0) ? 0.15 : 0.075; 
                }
            }

            const rad = angle * Math.PI / 180;
            const dLat = (speed * Math.cos(rad)) / 111320;
            const dLng = (speed * Math.sin(rad)) / (111320 * Math.cos(lat * Math.PI / 180));

            const nextLat = lat + dLat;
            const nextLng = lng + dLng;

            let hit = false;
            for (let i = 0; i < buildingPolygons.length; i++) {
                if (isPointInPolygon([nextLng, nextLat], buildingPolygons[i])) { hit = true; break; }
            }

            if (hit) {
                speed = -speed * 0.4; 
                if (isDriving) {
                    reputation -= 5.0; health -= 10; 
                    checkCarVisuals();
                    if (health <= 0) { triggerWasted("CARRO DESTRU√çDO!"); } 
                    else {
                        statusColor = "#f44336";
                        isHitFlashing = true; 
                        carElement.style.background = "yellow";
                        carElement.style.boxShadow = "0 0 20px 10px yellow";
                        setTimeout(() => {
                            isHitFlashing = false;
                            if (!isWasted && isDriving) carElement.style.background = "#d32f2f";
                        }, 150);
                    }
                } else { autoWalkToCar = false; }
            } else {
                lat = nextLat; lng = nextLng;
            }

            let stars = 0;
            if (reputation < 0) stars = 5;          
            else if (reputation < 500) stars = 4;   
            else if (reputation < 750) stars = 3;   
            else if (reputation < 900) stars = 2;   
            else if (reputation < 985) stars = 1;   

            for (let i = 1; i <= 5; i++) {
                const starEl = document.getElementById(`star-${i}`);
                if (i <= stars) starEl.classList.add('active');
                else starEl.classList.remove('active');
            }

            let targetPoliceCount = stars * 2; 
            if (policeCars.length < targetPoliceCount) {
                spawnPolice();
            } else if (policeCars.length > targetPoliceCount) {
                let p = policeCars.pop();
                p.element.remove();
            }
            updatePoliceAI(stars);

            if (Math.abs(speed) > 0.05) {
                let basePoints = 0.1; 
                let starBonus = stars * 0.05; 
                survivalScore += (basePoints + starBonus);
            }
        }

        function updateRender() {
            if (map) map.setView([lat, lng], 20, { animate: false });
            if (debugMode) drawDebugOverlay();

            policeCars.forEach(p => {
                if (map) {
                    const pos = map.latLngToContainerPoint([p.lat, p.lng]);
                    p.element.style.display = 'block';
                    p.element.style.left = pos.x + 'px';
                    p.element.style.top = pos.y + 'px';
                    p.element.style.transform = `rotate(${p.angle}deg)`;

                    // Atualiza classes visuais de estado
                    p.element.classList.toggle('ramming',       p.state === 'ram');
                    p.element.classList.toggle('stunned-state', p.state === 'stunned');
                }
            });

            if (isDriving) {
                carElement.style.left = '50%'; carElement.style.top = '50%';
                carElement.style.transform = `rotate(${angle}deg)`;
                playerElement.style.display = 'none';
            } else {
                playerElement.style.display = 'block';
                playerElement.style.transform = `rotate(${angle}deg) scale(0.8)`; 
                
                if (Math.abs(speed) > 0.01) {
                    let footOffset = Math.sin(walkCycle * 4) * 4; 
                    footL.style.transform = `translateY(${footOffset}px)`;
                    footR.style.transform = `translateY(${-footOffset}px)`;
                } else {
                    footL.style.transform = `translateY(0px)`;
                    footR.style.transform = `translateY(0px)`;
                }
                
                if (map) {
                    const carPos = map.latLngToContainerPoint([carLat, carLng]);
                    carElement.style.left = carPos.x + 'px'; carElement.style.top = carPos.y + 'px';
                    carElement.style.transform = `rotate(${carAngle}deg)`;
                }
            }

            const displaySpeed = Math.abs(Math.round(speed * 200)); 
            speedElement.innerText = displaySpeed;

            if (!isHitFlashing && isDriving && !isWasted) {
                let auraColor = "rgba(0,0,0,0.6)"; 
                let auraShadow = "0 8px 12px"; 
                
                if (infractionFrames > 0) {
                    let progress = infractionFrames / MAX_INFRACTION_FRAMES; 
                    if (progress < 0.5) {
                        auraColor = "rgba(255, 235, 59, 0.9)"; 
                        auraShadow = "0 0 20px 8px";
                    } else {
                        auraColor = "rgba(244, 67, 54, 1.0)"; 
                        auraShadow = "0 0 30px 10px";
                    }
                }
                carElement.style.boxShadow = `${auraShadow} ${auraColor}`;
            }

            if (isDriving && infractionFrames >= 90) { 
                thoughtBubbleElement.style.display = 'block';
                if (currentInfraction === 'offroad') thoughtBubbleElement.innerText = "Aqui n√£o √© lugar de dirigir!";
                else if (currentInfraction === 'wrongway') thoughtBubbleElement.innerText = "Nossa, aqui √© contram√£o!";
                else if (currentInfraction === 'speeding') thoughtBubbleElement.innerText = "Estou r√°pido demais!";
            } else {
                thoughtBubbleElement.style.display = 'none';
            }

            survivalScoreElement.innerText = Math.floor(survivalScore);
            repUiElement.style.borderColor = statusColor;

            if (displaySpeed !== 0 && isDriving) {
                instructionsElement.style.opacity = '0'; 
                titleElement.style.opacity = '0';
                searchElement.style.opacity = '0'; 
                searchElement.style.pointerEvents = 'none';
                instructionsElement.style.pointerEvents = 'none';
            } else {
                instructionsElement.style.opacity = '1'; 
                titleElement.style.opacity = '1';
                searchElement.style.opacity = '1'; 
                searchElement.style.pointerEvents = 'auto';
                instructionsElement.style.pointerEvents = 'auto';
            }
        }
    </script>
</body>
</html>
